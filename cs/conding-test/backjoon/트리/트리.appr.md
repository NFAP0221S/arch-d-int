# 📊 트리 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)

- 트리에서 **특정 노드를 제거**했을 때 **남은 리프 노드의 개수** 계산
- **리프 노드**: 자식이 없는 노드
- **노드 제거**: 해당 노드와 **모든 후손 노드가 함께 제거**됨
- **부모 배열**로 트리 구조가 주어짐 (루트는 -1)

## 2단계: 제약/엣지 케이스 점검

- 노드 개수 N: 1~50 (소규모 데이터, 완전탐색 가능)
- 노드 번호: 0~N-1
- **루트 노드 제거**: 전체 트리가 사라짐 → 리프 노드 0개
- **리프 노드 제거**: 제거된 노드만 사라짐
- **중간 노드 제거**: 서브트리 전체가 사라지고 부모가 새로운 리프가 될 수 있음
- **단일 노드 트리**: 루트만 있는 경우

## 3단계: 브루트포스(비추천) 떠올려보기

```javascript
// 직접 시뮬레이션: 제거 후 남은 노드들로 새 트리 구성
function solutionBrute(n, parents, removeNode) {
  // 제거할 노드들을 찾기
  const toRemove = new Set();

  function markForRemoval(node) {
    toRemove.add(node);
    for (let i = 0; i < n; i++) {
      if (parents[i] === node) {
        markForRemoval(i); // 자식들도 제거
      }
    }
  }

  markForRemoval(removeNode);

  // 남은 노드들로 새 트리 구성하고 리프 카운트
  let leafCount = 0;
  for (let i = 0; i < n; i++) {
    if (toRemove.has(i)) continue;

    let hasChild = false;
    for (let j = 0; j < n; j++) {
      if (!toRemove.has(j) && parents[j] === i) {
        hasChild = true;
        break;
      }
    }
    if (!hasChild) leafCount++;
  }

  return leafCount;
}
```
**문제점**: 비효율적인 반복 탐색, 코드 복잡성

## 4단계: 자료구조/알고리즘 선택 및 이유

- **인접 리스트**: 부모-자식 관계를 효율적으로 저장
- **DFS (깊이 우선 탐색)**: 노드 제거 시 모든 후손을 재귀적으로 처리
- **불린 배열**: 제거된 노드 상태 관리
- **선형 탐색**: 최종 리프 노드 개수 계산

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유

- **인접 리스트**: 부모 배열에서 자식 관계로 변환하여 탐색 효율성 향상
- **DFS**: 트리의 계층 구조를 자연스럽게 처리, 재귀로 간단히 구현
- **불린 배열**: O(1) 시간에 노드 제거 상태 확인
- **단일 패스**: 모든 노드를 한 번씩만 확인하여 리프 노드 판별

## 6단계: 조기 가지치기(Pruning)

- **루트 노드 제거 체크**: 루트가 제거되면 즉시 0 반환
- **자식 관계 미리 구축**: 부모 배열을 자식 배열로 변환하여 탐색 최적화
- **제거 상태 확인**: 이미 제거된 노드의 자식은 탐색하지 않음

## 7단계: 구현 (권장)

```javascript
function solution(n, parents, removeNode) {
  // 루트 노드 제거 시 즉시 반환
  if (removeNode === parents.indexOf(-1)) return 0;

  // 각 노드의 자식들을 저장할 인접 리스트
  const children = Array.from({ length: n }, () => []);

  // 부모-자식 관계 구축
  for (let i = 0; i < n; i++) {
    if (parents[i] !== -1) {
      children[parents[i]].push(i);
    }
  }

  // 제거할 노드들을 표시할 배열
  const removed = new Array(n).fill(false);

  // DFS로 제거할 노드와 그 후손들 표시
  function removeSubtree(node) {
    removed[node] = true;
    for (const child of children[node]) {
      removeSubtree(child);
    }
  }

  removeSubtree(removeNode);

  // 리프 노드 개수 계산
  let leafCount = 0;
  for (let i = 0; i < n; i++) {
    if (!removed[i]) {
      // 살아있는 자식이 있는지 확인
      const hasLivingChild = children[i].some(child => !removed[child]);
      if (!hasLivingChild) {
        leafCount++;
      }
    }
  }

  return leafCount;
}
```

## 8단계: 대안 구현

```javascript
// BFS를 활용한 구현
function solutionBFS(n, parents, removeNode) {
  const children = Array.from({ length: n }, () => []);

  for (let i = 0; i < n; i++) {
    if (parents[i] !== -1) {
      children[parents[i]].push(i);
    }
  }

  const removed = new Array(n).fill(false);
  const queue = [removeNode];

  while (queue.length > 0) {
    const node = queue.shift();
    removed[node] = true;

    for (const child of children[node]) {
      queue.push(child);
    }
  }

  // 리프 노드 개수 계산 (동일)
  let leafCount = 0;
  for (let i = 0; i < n; i++) {
    if (!removed[i] && !children[i].some(child => !removed[child])) {
      leafCount++;
    }
  }

  return leafCount;
}

// 재귀 없는 스택 기반 구현
function solutionStack(n, parents, removeNode) {
  const children = Array.from({ length: n }, () => []);

  for (let i = 0; i < n; i++) {
    if (parents[i] !== -1) {
      children[parents[i]].push(i);
    }
  }

  const removed = new Array(n).fill(false);
  const stack = [removeNode];

  while (stack.length > 0) {
    const node = stack.pop();
    removed[node] = true;

    for (const child of children[node]) {
      stack.push(child);
    }
  }

  return [...Array(n).keys()]
    .filter(i => !removed[i])
    .filter(i => !children[i].some(child => !removed[child]))
    .length;
}

// 함수형 프로그래밍 스타일
function solutionFunctional(n, parents, removeNode) {
  const buildChildren = (parents) =>
    parents.reduce((acc, parent, child) => {
      if (parent !== -1) {
        acc[parent] = [...(acc[parent] || []), child];
      }
      return acc;
    }, Array.from({ length: n }, () => []));

  const markRemoved = (children, removeNode) => {
    const removed = new Array(n).fill(false);

    const dfs = (node) => {
      removed[node] = true;
      children[node].forEach(dfs);
    };

    dfs(removeNode);
    return removed;
  };

  const countLeaves = (children, removed) =>
    [...Array(n).keys()]
      .filter(i => !removed[i])
      .filter(i => !children[i].some(child => !removed[child]))
      .length;

  const children = buildChildren(parents);
  const removed = markRemoved(children, removeNode);
  return countLeaves(children, removed);
}
```

## 9단계: 테스트 케이스 세트

```javascript
// 기본 케이스
console.log(solution(5, [-1, 0, 0, 1, 1], 2)); // 2
console.log(solution(5, [-1, 0, 0, 1, 1], 1)); // 1
console.log(solution(5, [-1, 0, 0, 1, 1], 0)); // 0

// 복잡한 트리
console.log(solution(9, [-1, 0, 0, 2, 2, 4, 4, 6, 6], 4)); // 2

// 엣지 케이스
console.log(solution(1, [-1], 0)); // 0 (단일 노드)
console.log(solution(2, [-1, 0], 1)); // 1 (리프 제거)
console.log(solution(2, [-1, 0], 0)); // 0 (루트 제거)

// 선형 트리 (연결 리스트 형태)
console.log(solution(4, [-1, 0, 1, 2], 1)); // 1
console.log(solution(4, [-1, 0, 1, 2], 2)); // 1

// 완전 이진 트리
console.log(solution(7, [-1, 0, 0, 1, 1, 2, 2], 1)); // 3

// 모든 노드가 루트의 자식
console.log(solution(5, [-1, 0, 0, 0, 0], 2)); // 3

// 깊은 트리
const deepParents = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8];
console.log(solution(10, deepParents, 5)); // 1
```

## 10단계: 복잡도/확장 & 면접 포인트

### 시간 복잡도
- **트리 구축**: O(N) - 부모 배열을 인접 리스트로 변환
- **DFS 제거**: O(제거되는 노드 수) ≤ O(N)
- **리프 카운트**: O(N) - 모든 노드 확인
- **전체**: O(N)

### 공간 복잡도
- **인접 리스트**: O(N) - 모든 간선 저장
- **제거 배열**: O(N)
- **재귀 스택**: O(트리 높이) ≤ O(N)
- **전체**: O(N)

### 면접 포인트
1. **트리 표현 방식**:
   - 부모 배열 vs 인접 리스트 vs 인접 행렬
   - 각 방식의 장단점과 선택 이유
2. **탐색 알고리즘 선택**:
   - DFS vs BFS: 트리에서는 DFS가 더 자연스러움
   - 재귀 vs 반복: 스택 오버플로우 고려사항
3. **최적화 기법**:
   - 조기 종료 조건 (루트 노드 제거)
   - 메모리 효율성 (불린 배열 사용)
4. **확장 가능성**:
   - **다중 노드 제거**: 여러 노드를 동시에 제거하는 경우
   - **동적 트리**: 노드 추가/제거가 빈번한 경우
   - **가중치 트리**: 노드에 가중치가 있는 경우
   - **실시간 쿼리**: 제거 노드가 실시간으로 변경되는 경우
5. **경계 조건**:
   - 빈 트리, 단일 노드
   - 루트 노드 제거
   - 존재하지 않는 노드 제거
6. **실제 응용**:
   - 파일 시스템에서 디렉토리 삭제
   - 조직도에서 부서 해체
   - 게임에서 스킬 트리 변경
   - 의존성 그래프에서 모듈 제거