# 📊 문자열 집합 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)
- N개의 문자열로 구성된 집합 S가 주어짐
- M개의 검사 대상 문자열이 주어짐
- 검사 문자열 중 집합 S에 포함된 개수를 구해야 함
- 문자열은 정확히 일치해야 함 (부분 문자열이 아닌 완전 일치)
- 집합 S에는 중복된 문자열이 없음

## 2단계: 제약/엣지 케이스 점검
- **입력 범위**: N, M ≤ 10,000 → 최대 10^8 연산까지 허용
- **문자열 길이**: 최대 500자 → 메모리 사용량 계산 필요
- **시간 제한**: 2초 → O(N×M) 브루트포스도 가능하지만 비효율적
- **메모리 제한**: 1536MB → 충분한 메모리
- **엣지 케이스**:
  - N=1, M=1인 최소 케이스
  - 모든 검사 문자열이 집합에 있는 경우
  - 모든 검사 문자열이 집합에 없는 경우
  - 비슷하지만 다른 문자열들 (예: "startlink" vs "starlink")

## 3단계: 브루트포스(비추천) 떠올려보기
```javascript
// 브루트포스 접근법
let count = 0;
for (let i = 0; i < M; i++) {
    for (let j = 0; j < N; j++) {
        if (checkStrings[i] === setStrings[j]) {
            count++;
            break;
        }
    }
}
```
- **시간복잡도**: O(N × M × L) (L은 평균 문자열 길이)
- **문제점**: 문자열 비교가 O(L)이므로 전체적으로 비효율적
- **최악의 경우**: 10,000 × 10,000 × 500 = 5×10^10 연산으로 시간 초과

## 4단계: 자료구조/알고리즘 선택 및 이유
**선택**: 해시셋(HashSet) 기반 멤버십 검사
- 집합 S를 해시셋으로 구성
- 각 검사 문자열에 대해 O(1) 평균 시간에 포함 여부 확인

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유
1. **시간 효율성**: 해시 검색은 평균 O(1), 전체 O(N+M)
2. **공간 효율성**: O(N) 공간만 필요
3. **구현 단순성**: 대부분의 언어에서 내장 해시셋 지원
4. **확실성**: 해시 충돌이 있어도 O(N+M) 보장
5. **확장성**: N, M이 더 커져도 선형적으로 확장

**대안 비교**:
- 정렬 + 이진탐색: O(N log N + M log N) - 더 느림
- 트라이(Trie): O(N×L + M×L) - 구현 복잡, 메모리 사용량 많음

## 6단계: 조기 가지치기(Pruning)
이 문제에서는 특별한 가지치기가 필요하지 않음:
- 모든 검사 문자열을 확인해야 함
- 해시셋 검색이 이미 최적화됨
- 단, 해시 함수 최적화로 충돌 최소화 가능

## 7단계: 구현 (권장)
```javascript
const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');

const [N, M] = input[0].split(' ').map(Number);

// 집합 S를 해시셋으로 구성
const setS = new Set();
for (let i = 1; i <= N; i++) {
    setS.add(input[i]);
}

// M개의 문자열 검사
let count = 0;
for (let i = N + 1; i <= N + M; i++) {
    if (setS.has(input[i])) {
        count++;
    }
}

console.log(count);
```

## 8단계: 대안 구현
### C++ (더 빠른 성능)
```cpp
#include <iostream>
#include <unordered_set>
#include <string>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int N, M;
    cin >> N >> M;

    unordered_set<string> setS;
    for (int i = 0; i < N; i++) {
        string str;
        cin >> str;
        setS.insert(str);
    }

    int count = 0;
    for (int i = 0; i < M; i++) {
        string str;
        cin >> str;
        if (setS.find(str) != setS.end()) {
            count++;
        }
    }

    cout << count << endl;
    return 0;
}
```

### Python (간결한 구현)
```python
import sys
input = sys.stdin.readline

N, M = map(int, input().split())
setS = set()

for _ in range(N):
    setS.add(input().strip())

count = 0
for _ in range(M):
    if input().strip() in setS:
        count += 1

print(count)
```

## 9단계: 테스트 케이스 세트
```
# 기본 테스트
5 11
baekjoononlinejudge
startlink
codeplus
sundaycoding
codingsh
baekjoon
codeplus
codeminus
startlink
starlink
sundaycoding
codingsh
codinghs
sondaycoding
startrink
icerink
→ 출력: 4

# 모두 포함
2 2
hello
world
hello
world
→ 출력: 2

# 모두 불포함
2 2
hello
world
hi
earth
→ 출력: 0

# 최소 케이스
1 1
test
test
→ 출력: 1

# 비슷한 문자열
3 3
abc
abcd
abcde
abc
ab
abcdef
→ 출력: 1
```

## 10단계: 복잡도/확장 & 면접 포인트
### 시간 복잡도
- **해시셋 구성**: O(N × L) (L은 평균 문자열 길이)
- **검색**: O(M × L)
- **전체**: O((N+M) × L)
- **해시 충돌 최악**: O(N×M×L) (거의 발생하지 않음)

### 공간 복잡도
- **해시셋 저장**: O(N × L)
- **추가 공간**: O(1)

### 면접 포인트
1. **왜 해시셋을 선택했는가?**
   - O(1) 평균 검색 시간
   - 집합 연산에 최적화됨

2. **다른 자료구조와의 비교**
   - 배열: O(N) 검색 시간
   - 정렬된 배열 + 이진탐색: O(log N) 검색
   - 트라이: 메모리 사용량 많음

3. **해시 충돌 대응**
   - 좋은 해시 함수 사용
   - 체이닝 또는 오픈 어드레싱

4. **확장성 고려**
   - N, M이 매우 클 때의 대안
   - 메모리 제한이 있을 때의 외부 정렬 활용

5. **실제 업무 적용**
   - 데이터베이스 인덱싱
   - 캐싱 시스템
   - 중복 제거 시스템