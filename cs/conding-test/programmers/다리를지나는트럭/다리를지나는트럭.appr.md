# 📊 다리를 지나는 트럭 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)

- **시간 기반 시뮬레이션**: 매 초마다 트럭들의 상태 변화 추적
- **이중 제약 조건**: 다리 길이 제한 & 무게 제한 동시 만족
- **순차 진입**: 트럭들은 주어진 순서대로만 다리에 진입 가능
- **완전 통과**: 트럭이 다리를 완전히 지나간 시점까지 시뮬레이션

## 2단계: 제약/엣지 케이스 점검

- bridge_length: 1~10,000
- weight: 1~10,000
- truck_weights 길이: 1~10,000
- **단일 트럭**: 다리 길이 + 1초
- **모든 트럭이 동시 진입 가능**: 무게 합이 제한 이하인 경우
- **극도로 무거운 트럭**: 한 번에 하나씩만 지날 수 있는 경우
- **다리 길이가 1**: 매 초마다 트럭이 바로 통과
- **다리 길이가 매우 긴 경우**: 대기 시간 최소화 전략 필요

## 3단계: 브루트포스(비추천) 떠올려보기

```javascript
// 매 초마다 모든 상태를 재계산
function solutionBrute(bridge_length, weight, truck_weights) {
  let time = 0;
  let trucks_on_bridge = []; // [트럭무게, 진입시간]
  let truck_index = 0;

  while (truck_index < truck_weights.length || trucks_on_bridge.length > 0) {
    time++;

    // 매번 모든 트럭의 위치를 다시 계산
    trucks_on_bridge = trucks_on_bridge.filter(([weight, enter_time]) => {
      return time - enter_time < bridge_length;
    });

    // 현재 무게 다시 계산
    let current_weight = trucks_on_bridge.reduce((sum, [w]) => sum + w, 0);

    // 새 트럭 진입 시도
    if (truck_index < truck_weights.length) {
      const next_truck = truck_weights[truck_index];
      if (trucks_on_bridge.length < bridge_length &&
          current_weight + next_truck <= weight) {
        trucks_on_bridge.push([next_truck, time]);
        truck_index++;
      }
    }
  }

  return time;
}
```
**문제점**: 매 초마다 불필요한 재계산, O(N×M) 시간복잡도

## 4단계: 자료구조/알고리즘 선택 및 이유

- **큐(Queue)**: 다리 위 트럭들의 FIFO 순서 관리
- **시간 기반 이벤트**: 각 트럭의 출구 시간 미리 계산
- **상태 추적**: 현재 다리 위 무게를 실시간으로 유지
- **시뮬레이션**: 이산적 시간 단위로 상태 변화 처리

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유

- **큐의 FIFO 특성**: 먼저 들어간 트럭이 먼저 나가는 자연스러운 순서
- **이벤트 기반 처리**: 트럭이 나갈 시간을 미리 계산하여 효율적 관리
- **실시간 무게 추적**: 매번 재계산 대신 증감으로 O(1) 업데이트
- **명확한 상태 관리**: 다리 위 상황을 직관적으로 모델링

## 6단계: 조기 가지치기(Pruning)

- **출구 시간 미리 계산**: 트럭 진입 시 나갈 시간을 저장하여 불필요한 검사 제거
- **무게 누적 관리**: 매번 합계 계산 대신 증감으로 처리
- **빈 큐 체크**: 모든 트럭이 처리되고 다리가 비면 즉시 종료
- **진입 불가 조건**: 무게나 길이 제한으로 진입 불가 시 시간만 증가

## 7단계: 구현 (권장)

```javascript
function solution(bridge_length, weight, truck_weights) {
  let time = 0;
  let bridge = []; // [트럭무게, 출구시간]
  let truck_index = 0;
  let current_weight = 0;

  while (truck_index < truck_weights.length || bridge.length > 0) {
    time++;

    // 다리를 완전히 건넌 트럭 제거
    if (bridge.length > 0 && bridge[0][1] === time) {
      const [truck_weight] = bridge.shift();
      current_weight -= truck_weight;
    }

    // 새 트럭 진입 시도
    if (truck_index < truck_weights.length) {
      const next_truck = truck_weights[truck_index];

      // 길이 제한과 무게 제한 모두 확인
      if (bridge.length < bridge_length &&
          current_weight + next_truck <= weight) {
        const exit_time = time + bridge_length;
        bridge.push([next_truck, exit_time]);
        current_weight += next_truck;
        truck_index++;
      }
    }
  }

  return time;
}
```

## 8단계: 대안 구현

```javascript
// 클래스 기반 구현
class Bridge {
  constructor(length, weight_limit) {
    this.length = length;
    this.weight_limit = weight_limit;
    this.trucks = [];
    this.current_weight = 0;
  }

  tick(time) {
    // 출구에 도달한 트럭들 제거
    while (this.trucks.length > 0 && this.trucks[0].exit_time === time) {
      const truck = this.trucks.shift();
      this.current_weight -= truck.weight;
    }
  }

  can_enter(truck_weight) {
    return this.trucks.length < this.length &&
           this.current_weight + truck_weight <= this.weight_limit;
  }

  enter_truck(truck_weight, time) {
    const truck = {
      weight: truck_weight,
      exit_time: time + this.length
    };
    this.trucks.push(truck);
    this.current_weight += truck_weight;
  }

  is_empty() {
    return this.trucks.length === 0;
  }
}

function solutionOOP(bridge_length, weight, truck_weights) {
  const bridge = new Bridge(bridge_length, weight);
  let time = 0;
  let truck_index = 0;

  while (truck_index < truck_weights.length || !bridge.is_empty()) {
    time++;
    bridge.tick(time);

    if (truck_index < truck_weights.length &&
        bridge.can_enter(truck_weights[truck_index])) {
      bridge.enter_truck(truck_weights[truck_index], time);
      truck_index++;
    }
  }

  return time;
}

// 함수형 프로그래밍 스타일
function solutionFunctional(bridge_length, weight, truck_weights) {
  const simulate = (state) => {
    if (state.truck_index >= truck_weights.length && state.bridge.length === 0) {
      return state.time;
    }

    const new_time = state.time + 1;

    // 트럭 제거
    const { bridge: new_bridge, weight: new_weight } = state.bridge
      .filter(([_, exit_time]) => exit_time !== new_time)
      .reduce(
        (acc, truck) => ({
          bridge: [...acc.bridge, truck],
          weight: acc.weight + truck[0]
        }),
        { bridge: [], weight: 0 }
      );

    // 트럭 진입
    const can_enter = state.truck_index < truck_weights.length &&
                     new_bridge.length < bridge_length &&
                     new_weight + truck_weights[state.truck_index] <= weight;

    const final_state = can_enter
      ? {
          time: new_time,
          bridge: [...new_bridge, [truck_weights[state.truck_index], new_time + bridge_length]],
          truck_index: state.truck_index + 1
        }
      : {
          time: new_time,
          bridge: new_bridge,
          truck_index: state.truck_index
        };

    return simulate(final_state);
  };

  return simulate({
    time: 0,
    bridge: [],
    truck_index: 0
  });
}

// 우선순위 큐를 활용한 이벤트 기반 구현
function solutionEventBased(bridge_length, weight, truck_weights) {
  const events = []; // [시간, 이벤트타입, 데이터]
  let time = 0;
  let truck_index = 0;
  let current_weight = 0;
  let trucks_on_bridge = 0;

  while (truck_index < truck_weights.length || trucks_on_bridge > 0) {
    time++;

    // 현재 시간의 모든 이벤트 처리
    while (events.length > 0 && events[0][0] === time) {
      const [_, event_type, truck_weight] = events.shift();
      if (event_type === 'exit') {
        current_weight -= truck_weight;
        trucks_on_bridge--;
      }
    }

    // 새 트럭 진입 시도
    if (truck_index < truck_weights.length) {
      const next_truck = truck_weights[truck_index];

      if (trucks_on_bridge < bridge_length &&
          current_weight + next_truck <= weight) {
        // 진입 이벤트
        current_weight += next_truck;
        trucks_on_bridge++;
        truck_index++;

        // 출구 이벤트 예약
        events.push([time + bridge_length, 'exit', next_truck]);
        events.sort((a, b) => a[0] - b[0]); // 시간순 정렬
      }
    }
  }

  return time;
}
```

## 9단계: 테스트 케이스 세트

```javascript
// 기본 케이스
console.log(solution(2, 10, [7, 4, 5, 6])); // 8

// 단일 트럭
console.log(solution(100, 100, [10])); // 101

// 모든 트럭이 동시 진입 가능
console.log(solution(100, 100, [10, 10, 10, 10, 10, 10, 10, 10, 10, 10])); // 110

// 최소 케이스
console.log(solution(1, 1, [1])); // 2
console.log(solution(1, 2, [1, 1])); // 3

// 무게 제한에 걸리는 경우
console.log(solution(2, 10, [10, 10])); // 4

// 길이 제한에 걸리는 경우
console.log(solution(1, 100, [1, 1, 1])); // 4

// 극단적인 경우
console.log(solution(1, 1, [1, 1, 1, 1, 1])); // 6

// 복잡한 혼합 케이스
console.log(solution(3, 15, [5, 5, 5, 5, 3, 3, 3])); // ?

// 성능 테스트
const large_trucks = Array(1000).fill(1);
console.time("Large test");
console.log(solution(100, 1000, large_trucks));
console.timeEnd("Large test");

// 엣지 케이스: 무게가 정확히 맞는 경우
console.log(solution(2, 10, [5, 5, 5, 5])); // ?

// 트럭이 하나씩만 지날 수 있는 경우
console.log(solution(3, 5, [5, 5, 5])); // 9
```

## 10단계: 복잡도/확장 & 면접 포인트

### 시간 복잡도
- **기본 구현**: O(N × bridge_length) - 최악의 경우 모든 트럭이 한 번에 하나씩
- **최적화된 구현**: O(N) - 각 트럭을 상수 시간에 처리
- **공간 복잡도**: O(bridge_length) - 다리 위 트럭 개수만큼

### 면접 포인트
1. **시뮬레이션 설계**:
   - 실시간 vs 이벤트 기반 처리 방식
   - 상태 관리의 복잡성과 정확성
2. **자료구조 선택**:
   - 큐의 자연스러운 FIFO 특성 활용
   - 배열 vs 연결리스트 성능 차이
3. **최적화 기법**:
   - 출구 시간 미리 계산
   - 무게 누적 관리
   - 불필요한 재계산 제거
4. **확장 가능성**:
   - **다차선 다리**: 여러 차선이 있는 경우
   - **우선순위 시스템**: 응급차량 등 우선권
   - **동적 무게 변경**: 트럭이 화물을 떨어뜨리는 경우
   - **실시간 모니터링**: 현재 다리 상황 실시간 조회
   - **통행료 계산**: 시간이나 무게에 따른 요금 체계
5. **실제 응용 분야**:
   - 교통 시뮬레이션 시스템
   - 네트워크 패킷 전송 (대역폭 제한)
   - 공장 컨베이어 벨트 시스템
   - 엘리베이터 스케줄링
   - 주차장 입출차 관리
6. **예외 상황 처리**:
   - 트럭 무게가 다리 제한을 초과하는 경우
   - 다리 길이가 0인 경우
   - 빈 트럭 배열 처리
   - 정수 오버플로우 고려사항