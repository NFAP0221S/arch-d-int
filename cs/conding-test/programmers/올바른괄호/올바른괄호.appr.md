# 📊 올바른 괄호 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)

- 괄호 문자열이 **올바르게 짝지어졌는지** 판단
- `'('`로 열린 괄호는 반드시 `')'`로 닫혀야 함
- **순서가 중요**: 닫는 괄호가 먼저 나오면 안 됨
- 모든 괄호가 **완전히 짝지어져야** 함

## 2단계: 제약/엣지 케이스 점검

- 문자열 길이: 1~100,000 (대용량 가능)
- 문자 종류: `'('`, `')'` 만 존재
- **홀수 길이**: 무조건 false (짝이 맞지 않음)
- **빈 문자열**: 문제에서 제외됨 (길이 1 이상)
- **첫 문자가 ')'**: 무조건 false
- **마지막 문자가 '('**: 무조건 false

## 3단계: 브루트포스(비추천) 떠올려보기

```javascript
// 스택을 사용한 전통적인 접근법
function solutionStack(s) {
  const stack = [];

  for (const char of s) {
    if (char === '(') {
      stack.push(char);
    } else { // char === ')'
      if (stack.length === 0) return false;
      stack.pop();
    }
  }

  return stack.length === 0;
}
```
**문제점**: 스택 자료구조가 필요하고 메모리 사용량이 많음

## 4단계: 자료구조/알고리즘 선택 및 이유

- **카운터 방식**: 스택 없이 정수 변수 하나로 해결
- **선형 순회**: 한 번의 루프로 O(N) 시간에 처리
- **조건 검사**: 카운터가 음수가 되는 순간 즉시 false 반환

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유

- **카운터 방식**:
  - 메모리 O(1) 사용
  - 스택 push/pop 연산 불필요
  - 괄호의 깊이만 중요하므로 카운터로 충분
- **조기 종료**: 불가능한 상황을 즉시 감지하여 효율성 향상

## 6단계: 조기 가지치기(Pruning)

- **길이 검사**: 홀수 길이면 즉시 false 반환
- **첫 문자 검사**: ')'로 시작하면 즉시 false
- **카운터 음수 검사**: 중간에 카운터가 음수가 되면 즉시 false
- **마지막 카운터 검사**: 0이 아니면 false

## 7단계: 구현 (권장)

```javascript
function solution(s) {
  // 조기 가지치기: 홀수 길이는 불가능
  if (s.length % 2 !== 0) return false;

  let count = 0;

  for (const char of s) {
    if (char === '(') {
      count++;
    } else { // char === ')'
      if (count === 0) return false; // 닫을 괄호가 없음
      count--;
    }
  }

  return count === 0; // 모든 괄호가 짝지어짐
}

// 더 간결한 버전
function solutionConcise(s) {
  let count = 0;
  for (const ch of s) {
    count += ch === '(' ? 1 : -1;
    if (count < 0) return false;
  }
  return count === 0;
}
```

## 8단계: 대안 구현

```javascript
// 정규표현식을 활용한 방법 (비효율적)
function solutionRegex(s) {
  while (s.includes('()')) {
    s = s.replace(/\(\)/g, '');
  }
  return s.length === 0;
}

// 재귀적 접근법
function solutionRecursive(s, index = 0, count = 0) {
  if (count < 0) return false;
  if (index === s.length) return count === 0;

  const char = s[index];
  const newCount = char === '(' ? count + 1 : count - 1;

  return solutionRecursive(s, index + 1, newCount);
}

// 양방향 검사 (최적화)
function solutionTwoPointer(s) {
  if (s.length % 2 !== 0) return false;

  let left = 0, right = s.length - 1;
  let leftCount = 0, rightCount = 0;

  while (left <= right) {
    // 왼쪽에서 오른쪽으로
    if (s[left] === '(') leftCount++;
    else leftCount--;

    // 오른쪽에서 왼쪽으로
    if (s[right] === ')') rightCount++;
    else rightCount--;

    if (leftCount < 0 || rightCount < 0) return false;

    left++;
    right--;
  }

  return leftCount === rightCount;
}
```

## 9단계: 테스트 케이스 세트

```javascript
// 기본 올바른 괄호
console.log(solution("()")); // true
console.log(solution("(())()")); // true
console.log(solution("((()))")); // true

// 기본 잘못된 괄호
console.log(solution(")()(")); // false
console.log(solution("(()(")); // false
console.log(solution("())(")); // false

// 엣지 케이스
console.log(solution("(")); // false (홀수 길이)
console.log(solution(")")); // false (닫는 괄호로 시작)
console.log(solution("")); // true (빈 문자열, 문제에서 제외)

// 극단적인 경우
console.log(solution("(".repeat(50000) + ")".repeat(50000))); // true
console.log(solution(")".repeat(50000) + "(".repeat(50000))); // false

// 복잡한 중첩
console.log(solution("((((((()))))))")); // true
console.log(solution("((((((()))))))")); // false (짝 안맞음)

// 혼합 패턴
console.log(solution("()()()()")); // true
console.log(solution("(()()())")); // true
console.log(solution("(()()()")); // false
```

## 10단계: 복잡도/확장 & 면접 포인트

### 시간 복잡도
- **카운터 방식**: O(N) - 문자열을 한 번 순회
- **스택 방식**: O(N) - 같은 시간복잡도지만 상수 배수가 더 큼

### 공간 복잡도
- **카운터 방식**: O(1) - 변수 하나만 사용
- **스택 방식**: O(N) - 최악의 경우 모든 문자를 스택에 저장

### 면접 포인트
1. **최적화 접근법**: 스택 → 카운터로의 개선 과정 설명
2. **조기 종료 조건들**:
   - 홀수 길이 검사
   - 음수 카운터 검사
   - 첫 문자/마지막 문자 패턴 분석
3. **확장 가능성**:
   - 여러 종류의 괄호 `()`, `[]`, `{}` 처리
   - 중첩 깊이 제한 추가
   - 실시간 스트리밍 데이터 처리
4. **엣지 케이스 처리**:
   - 빈 문자열
   - 단일 문자
   - 매우 긴 문자열
5. **성능 비교**:
   - 메모리 사용량: O(1) vs O(N)
   - 실행 속도: 카운터 방식이 더 빠름
   - 코드 가독성: 두 방식 모두 직관적
6. **실제 응용**:
   - 컴파일러의 문법 검사
   - 수식 파싱
   - XML/HTML 태그 검증