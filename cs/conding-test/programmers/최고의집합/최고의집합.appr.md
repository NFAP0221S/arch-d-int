# 📊 최고의 집합 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)
- n개의 자연수로 구성된 집합에서 원소들의 합이 s가 되어야 함
- 위 조건을 만족하면서 **원소들의 곱이 최대**가 되는 집합을 찾아야 함
- 결과는 오름차순으로 정렬된 배열로 반환
- 조건을 만족하는 집합이 존재하지 않으면 [-1] 반환
- **핵심**: 수학적 최적화 문제 (제약 조건부 곱 최대화)

## 2단계: 제약/엣지 케이스 점검
- **자연수 조건**: 모든 원소 ≥ 1
- **불가능 조건**: n > s (자연수 n개의 최소 합은 n)
- **입력 범위**: 1 ≤ n ≤ 10,000, 1 ≤ s ≤ 100,000,000
- **엣지 케이스**:
  - n = s인 경우 → 모든 원소가 1
  - s가 n으로 나누어떨어지는 경우 → 모든 원소가 동일
  - s가 n으로 나누어떨어지지 않는 경우 → 일부 원소가 1 큼

## 3단계: 브루트포스(비추천) 떠올려보기
```javascript
// 모든 가능한 조합 시도 (매우 비효율적)
function bruteForce(n, s) {
    let maxProduct = 0;
    let bestSet = [-1];

    function generateCombinations(current, sum, count) {
        if (count === n) {
            if (sum === s) {
                const product = current.reduce((acc, val) => acc * val, 1);
                if (product > maxProduct) {
                    maxProduct = product;
                    bestSet = [...current].sort((a, b) => a - b);
                }
            }
            return;
        }

        for (let i = 1; i <= s; i++) {
            if (sum + i <= s) {
                current.push(i);
                generateCombinations(current, sum + i, count + 1);
                current.pop();
            }
        }
    }

    generateCombinations([], 0, 0);
    return bestSet;
}
```
- **문제점**:
  - 시간복잡도: O(s^n) → 매우 비효율적
  - s=100,000,000, n=10,000인 경우 실행 불가능
  - 수학적 최적화 원리를 무시한 무차별 대입

## 4단계: 자료구조/알고리즘 선택 및 이유
**선택**: 수학적 최적화 + 그리디 분배 알고리즘
- **핵심 이론**: 산술-기하 평균 부등식 (AM-GM Inequality)
- **분배 전략**: 균등 분배 + 나머지 처리
- **시간복잡도**: O(n)
- **공간복잡도**: O(n)

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유
1. **수학적 근거**:
   - AM-GM 부등식: (a₁+a₂+...+aₙ)/n ≥ ⁿ√(a₁×a₂×...×aₙ)
   - 등호 성립 조건: 모든 원소가 같을 때
   - **결론**: 원소들이 최대한 균등할 때 곱이 최대

2. **직관적 이해**:
   - 예: 합이 8인 2개 수 → {1,7}=7 < {2,6}=12 < {3,5}=15 < {4,4}=16
   - 차이가 클수록 곱이 작아짐

3. **그리디 선택의 정당성**:
   - 지역 최적해가 전역 최적해가 되는 문제
   - 수학적으로 증명 가능한 최적 전략

4. **효율성**:
   - 복잡한 탐색 없이 O(n) 시간에 해결
   - 메모리 사용량 최소화

## 6단계: 조기 가지치기(Pruning)
이 문제에서는 수학적 공식으로 직접 해를 구하므로 별도의 가지치기가 필요 없음:

1. **불가능 조건 체크**:
   ```javascript
   if (n > s) return [-1]; // 즉시 종료
   ```

2. **최적화 기법**:
   - 나머지 분배 시 뒤쪽부터 처리하여 정렬 상태 유지
   - 불필요한 정렬 과정 생략

## 7단계: 구현 (권장)
```javascript
function solution(n, s) {
    // 1. 불가능한 경우 체크
    if (n > s) {
        return [-1];
    }

    // 2. 기본 분배: 모든 원소를 s/n의 몫으로 초기화
    const quotient = Math.floor(s / n);
    const remainder = s % n;

    // 3. 결과 배열 생성 (모든 원소를 quotient로 초기화)
    const result = new Array(n).fill(quotient);

    // 4. 나머지를 뒤쪽 원소들에 1씩 분배
    // 뒤쪽부터 분배하여 오름차순 유지
    for (let i = n - remainder; i < n; i++) {
        result[i]++;
    }

    return result;
}
```

### 알고리즘 동작 과정
1. **기본 분배**: 각 원소에 s÷n의 몫을 할당
2. **나머지 처리**: s%n개의 원소에 1씩 추가 분배
3. **정렬 유지**: 뒤쪽 원소부터 증가시켜 자동으로 오름차순 유지

## 8단계: 대안 구현
### 수학적 증명 포함 버전
```javascript
function solution(n, s) {
    // AM-GM 부등식 기반 최적해 계산
    if (n > s) return [-1];

    // 이상적인 값: s/n (실수)
    const idealValue = s / n;
    const baseValue = Math.floor(idealValue);
    const remainder = s - (baseValue * n);

    // remainder개의 원소는 baseValue+1, 나머지는 baseValue
    const result = new Array(n);

    for (let i = 0; i < n - remainder; i++) {
        result[i] = baseValue;
    }

    for (let i = n - remainder; i < n; i++) {
        result[i] = baseValue + 1;
    }

    return result;
}
```

### 재귀적 분배 버전 (비추천, 교육용)
```javascript
function solution(n, s) {
    if (n > s) return [-1];

    function distribute(remaining, count) {
        if (count === 1) return [remaining];

        const avg = Math.floor(remaining / count);
        const rest = distribute(remaining - avg, count - 1);
        return [avg, ...rest];
    }

    const result = distribute(s, n);

    // 균등화 처리 (작은 값부터 큰 값으로 조정)
    result.sort((a, b) => a - b);

    // 더 균등하게 만들기 위한 조정
    while (true) {
        let adjusted = false;
        for (let i = 0; i < n - 1; i++) {
            if (result[i + 1] - result[i] > 1) {
                result[i]++;
                result[i + 1]--;
                adjusted = true;
            }
        }
        if (!adjusted) break;
    }

    return result;
}
```

### 함수형 프로그래밍 스타일
```javascript
const solution = (n, s) => {
    if (n > s) return [-1];

    const quotient = Math.floor(s / n);
    const remainder = s % n;

    return Array.from({ length: n }, (_, i) =>
        quotient + (i >= n - remainder ? 1 : 0)
    );
};
```

## 9단계: 테스트 케이스 세트
```javascript
// 기본 테스트 케이스
const testCases = [
    // 예제 케이스
    { n: 2, s: 9, expected: [4, 5] },
    { n: 2, s: 1, expected: [-1] },
    { n: 2, s: 8, expected: [4, 4] },

    // 경계 케이스
    { n: 1, s: 1, expected: [1] },              // 최소 케이스
    { n: 1, s: 100000000, expected: [100000000] }, // 최대 단일 값
    { n: 10000, s: 10000, expected: Array(10000).fill(1) }, // 모든 원소가 1

    // 나누어떨어지는 케이스
    { n: 3, s: 12, expected: [4, 4, 4] },
    { n: 4, s: 20, expected: [5, 5, 5, 5] },

    // 나누어떨어지지 않는 케이스
    { n: 3, s: 10, expected: [3, 3, 4] },
    { n: 4, s: 10, expected: [2, 2, 3, 3] },
    { n: 5, s: 13, expected: [2, 2, 3, 3, 3] },

    // 불가능한 케이스
    { n: 5, s: 4, expected: [-1] },
    { n: 100, s: 50, expected: [-1] },

    // 큰 수 케이스
    { n: 1000, s: 1000000, expected: Array(1000).fill(1000) },
    { n: 100, s: 301, expected: [...Array(99).fill(3), 4] }
];

// 검증 함수
function verifyTestCase(testCase) {
    const result = solution(testCase.n, testCase.s);
    const expected = testCase.expected;

    // 결과 검증
    if (JSON.stringify(result) !== JSON.stringify(expected)) {
        console.log(`Failed: n=${testCase.n}, s=${testCase.s}`);
        console.log(`Expected: ${expected}, Got: ${result}`);
        return false;
    }

    // 추가 검증 (합과 곱)
    if (result[0] !== -1) {
        const sum = result.reduce((a, b) => a + b, 0);
        if (sum !== testCase.s) {
            console.log(`Sum verification failed: expected ${testCase.s}, got ${sum}`);
            return false;
        }
    }

    return true;
}
```

## 10단계: 복잡도/확장 & 면접 포인트
### 시간 복잡도
- **전체**: O(n)
- **분배 과정**: O(1) - 수학적 계산
- **배열 생성**: O(n) - n개 원소 할당
- **나머지 처리**: O(remainder) = O(n) - 최악의 경우

### 공간 복잡도
- **결과 배열**: O(n)
- **추가 변수**: O(1)
- **전체**: O(n)

### 면접 포인트
1. **수학적 이해도**:
   - "왜 균등 분배가 최적인가요?" → AM-GM 부등식 설명
   - "다른 분배 방법은 왜 최적이 아닌가요?" → 수학적 증명

2. **알고리즘 설계**:
   - "브루트포스 대신 이 방법을 선택한 이유는?" → 시간복잡도 비교
   - "정렬이 필요한 이유는?" → 문제 요구사항

3. **구현 최적화**:
   - "나머지를 앞에서부터 분배하면 안 되나요?" → 정렬 순서 유지 문제
   - "더 효율적인 방법이 있을까요?" → 이미 O(n) 최적

4. **엣지 케이스 처리**:
   - "불가능한 경우를 어떻게 판단하나요?"
   - "큰 수에 대한 처리는 어떻게 하나요?"

5. **확장성 고려**:
   - "실수 조건이라면 어떻게 해결할까요?" → 라그랑주 승수법
   - "3차원 이상의 제약이 있다면?" → 최적화 이론 적용

6. **실제 응용**:
   - 리소스 분배 최적화 (CPU, 메모리 할당)
   - 투자 포트폴리오 최적화
   - 생산량 분배 문제

### 수학적 증명 (보너스)
**정리**: 합이 S인 n개 양수의 곱이 최대가 되려면 모든 수가 S/n에 가까워야 한다.

**증명**: 라그랑주 승수법 사용
- 목적함수: f(x₁, x₂, ..., xₙ) = x₁ × x₂ × ... × xₙ (최대화)
- 제약조건: g(x₁, x₂, ..., xₙ) = x₁ + x₂ + ... + xₙ - S = 0
- 라그랑주 함수: L = f - λg
- 최적조건: ∂L/∂xᵢ = 0 → 모든 xᵢ가 같아야 함