# 📊 양과 늑대 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)
- 이진 트리에서 루트(0번)부터 시작하여 양을 최대한 많이 수집
- 각 노드 방문 시 그 노드의 동물(양 또는 늑대)이 따라옴
- **핵심 제약**: 늑대 수 ≥ 양 수가 되면 모든 양이 잡아먹힘 (게임 오버)
- 방문한 노드는 재방문 불가능하지만, 이미 방문한 노드를 거쳐 다른 노드로 이동 가능
- 목표: 제약 조건을 지키면서 수집 가능한 양의 최대 개수

## 2단계: 제약/엣지 케이스 점검
- **노드 수**: 2 ≤ N ≤ 17 → 작은 입력 크기로 완전탐색 가능
- **시간 제한**: 10초 → 충분한 시간
- **트리 구조**: 이진 트리이므로 각 노드당 최대 2개의 자식
- **시작 조건**: 루트에 항상 양이 있음 (info[0] = 0)
- **엣지 케이스**:
  - 모든 노드가 양인 경우 → 모든 노드 방문 가능
  - 루트의 바로 자식이 늑대인 경우 → 신중한 경로 선택 필요
  - 늑대가 연속으로 많은 경우 → 양을 먼저 충분히 모아야 함

## 3단계: 브루트포스(비추천) 떠올려보기
```javascript
// 단순한 모든 순열 시도 (잘못된 접근)
function bruteForce(info, edges) {
    const n = info.length;
    const visited = new Array(n).fill(false);

    function permute(path, sheep, wolf) {
        if (wolf >= sheep && sheep > 0) return 0; // 잡아먹힘

        let maxSheep = sheep;
        for (let i = 0; i < n; i++) {
            if (!visited[i] && isReachable(path, i)) {
                visited[i] = true;
                const newSheep = sheep + (info[i] === 0 ? 1 : 0);
                const newWolf = wolf + (info[i] === 1 ? 1 : 0);
                maxSheep = Math.max(maxSheep, permute([...path, i], newSheep, newWolf));
                visited[i] = false;
            }
        }
        return maxSheep;
    }

    return permute([0], 1, 0);
}
```
- **문제점**:
  - 트리 구조를 무시하고 모든 노드 순열 시도
  - 도달 가능성 체크가 복잡
  - 불필요한 중복 계산

## 4단계: 자료구조/알고리즘 선택 및 이유
**선택**: DFS + 백트래킹 + 상태 기반 탐색
- **상태 정의**: (현재위치, 방문가능한노드집합, 양수, 늑대수)
- **탐색 방법**: 각 상태에서 방문 가능한 모든 노드로 DFS 진행
- **가지치기**: 늑대 수 ≥ 양 수인 경우 즉시 백트래킹

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유
1. **트리 구조 특성 활용**:
   - 부모 방문 후 자식 노드들이 방문 가능해짐
   - 이미 방문한 노드를 거쳐 다른 노드 접근 가능

2. **상태 공간 최적화**:
   - 방문 가능한 노드 집합을 동적으로 관리
   - 불가능한 경로 조기 차단

3. **백트래킹 효율성**:
   - 늑대 ≥ 양 조건으로 즉시 가지치기
   - N ≤ 17이므로 지수 복잡도도 허용 가능

4. **메모리 효율성**:
   - 재귀 스택만 사용, 추가 메모리 최소화

## 6단계: 조기 가지치기(Pruning)
1. **즉시 백트래킹 조건**:
   ```javascript
   if (wolf >= sheep) return; // 더 이상 진행 불가
   ```

2. **최적화 기법**:
   - 현재까지의 최대 양 수와 비교하여 더 이상 개선 불가능한 경우 조기 종료
   - 방문 가능한 노드가 없는 경우 종료

3. **메모이제이션** (선택적):
   ```javascript
   const memo = new Map();
   const stateKey = `${current}-${Array.from(visitableNodes).sort().join(',')}-${sheep}-${wolf}`;
   if (memo.has(stateKey)) return memo.get(stateKey);
   ```

## 7단계: 구현 (권장)
```javascript
function solution(info, edges) {
    // 트리 구조 생성
    const tree = {};
    for (const [parent, child] of edges) {
        if (!tree[parent]) tree[parent] = [];
        tree[parent].push(child);
    }

    let maxSheep = 0;

    function dfs(current, visitableNodes, sheep, wolf) {
        // 현재 노드의 동물 추가
        if (info[current] === 0) sheep++;
        else wolf++;

        // 늑대가 양보다 많아지면 종료 (가지치기)
        if (wolf >= sheep) return;

        // 최대 양 수 업데이트
        maxSheep = Math.max(maxSheep, sheep);

        // 새로운 방문 가능 노드 집합 생성
        const newVisitableNodes = new Set(visitableNodes);
        newVisitableNodes.delete(current); // 현재 노드 제거

        // 현재 노드의 자식들을 방문 가능 노드에 추가
        if (tree[current]) {
            for (const child of tree[current]) {
                newVisitableNodes.add(child);
            }
        }

        // 방문 가능한 모든 노드에 대해 DFS 진행
        for (const next of newVisitableNodes) {
            dfs(next, newVisitableNodes, sheep, wolf);
        }
    }

    // 0번 노드에서 시작 (루트 노드는 초기에 방문 가능)
    dfs(0, new Set([0]), 0, 0);

    return maxSheep;
}
```

## 8단계: 대안 구현
### 메모이제이션 추가 버전
```javascript
function solution(info, edges) {
    const tree = {};
    for (const [parent, child] of edges) {
        if (!tree[parent]) tree[parent] = [];
        tree[parent].push(child);
    }

    let maxSheep = 0;
    const memo = new Map();

    function dfs(current, visitableNodes, sheep, wolf) {
        // 상태 키 생성 (메모이제이션용)
        const nodeArray = Array.from(visitableNodes).sort();
        const stateKey = `${current}-${nodeArray.join(',')}-${sheep}-${wolf}`;

        if (memo.has(stateKey)) return memo.get(stateKey);

        if (info[current] === 0) sheep++;
        else wolf++;

        if (wolf >= sheep) {
            memo.set(stateKey, 0);
            return 0;
        }

        maxSheep = Math.max(maxSheep, sheep);

        const newVisitableNodes = new Set(visitableNodes);
        newVisitableNodes.delete(current);

        if (tree[current]) {
            for (const child of tree[current]) {
                newVisitableNodes.add(child);
            }
        }

        let result = sheep;
        for (const next of newVisitableNodes) {
            result = Math.max(result, dfs(next, newVisitableNodes, sheep, wolf));
        }

        memo.set(stateKey, result);
        return result;
    }

    dfs(0, new Set([0]), 0, 0);
    return maxSheep;
}
```

### BFS 기반 버전 (상태 큐 사용)
```javascript
function solution(info, edges) {
    const tree = {};
    for (const [parent, child] of edges) {
        if (!tree[parent]) tree[parent] = [];
        tree[parent].push(child);
    }

    const queue = [[0, new Set([0]), 0, 0]]; // [현재노드, 방문가능노드, 양, 늑대]
    let maxSheep = 0;
    const visited = new Set();

    while (queue.length > 0) {
        const [current, visitableNodes, sheep, wolf] = queue.shift();

        const newSheep = sheep + (info[current] === 0 ? 1 : 0);
        const newWolf = wolf + (info[current] === 1 ? 1 : 0);

        if (newWolf >= newSheep) continue;

        maxSheep = Math.max(maxSheep, newSheep);

        const newVisitableNodes = new Set(visitableNodes);
        newVisitableNodes.delete(current);

        if (tree[current]) {
            for (const child of tree[current]) {
                newVisitableNodes.add(child);
            }
        }

        const stateKey = Array.from(newVisitableNodes).sort().join(',');
        if (visited.has(stateKey)) continue;
        visited.add(stateKey);

        for (const next of newVisitableNodes) {
            queue.push([next, new Set(newVisitableNodes), newSheep, newWolf]);
        }
    }

    return maxSheep;
}
```

## 9단계: 테스트 케이스 세트
```javascript
// 테스트 케이스 1: 기본 예제
const test1 = {
    info: [0,0,1,1,1,0,1,0,1,0,1,1],
    edges: [[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]],
    expected: 5
};

// 테스트 케이스 2: 모든 노드가 양
const test2 = {
    info: [0,0,0,0,0],
    edges: [[0,1],[0,2],[1,3],[1,4]],
    expected: 5
};

// 테스트 케이스 3: 늑대가 많은 경우
const test3 = {
    info: [0,1,1,1,0],
    edges: [[0,1],[0,2],[1,3],[2,4]],
    expected: 2
};

// 테스트 케이스 4: 최소 케이스
const test4 = {
    info: [0,1],
    edges: [[0,1]],
    expected: 1
};

// 테스트 케이스 5: 복잡한 트리
const test5 = {
    info: [0,1,0,1,1,0,1,0,0,1,0],
    edges: [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]],
    expected: 5
};
```

## 10단계: 복잡도/확장 & 면접 포인트
### 시간 복잡도
- **최악의 경우**: O(2^N × N)
  - 각 노드에서 2가지 선택 (방문 or 미방문)
  - N번의 레벨에서 각각 N개 노드 처리
- **실제 성능**: 가지치기로 인해 훨씬 빠름
- **N ≤ 17**: 2^17 ≈ 131,072로 충분히 해결 가능

### 공간 복잡도
- **재귀 스택**: O(N) - 최대 깊이 N
- **방문 가능 노드 집합**: O(N) - 최대 N개 노드
- **트리 저장**: O(N) - 간선 정보
- **전체**: O(N)

### 면접 포인트
1. **알고리즘 선택 이유**:
   - "왜 DFS를 선택했나요?" → 모든 경로 탐색 필요, 백트래킹으로 효율성 확보
   - "BFS도 가능한가요?" → 가능하지만 메모리 사용량 많음, 상태 관리 복잡

2. **최적화 기법**:
   - "시간 복잡도를 더 줄일 수 있나요?" → 메모이제이션, 더 강한 가지치기 조건
   - "메모리를 더 절약할 방법은?" → 비트마스크로 방문 상태 표현

3. **엣지 케이스 처리**:
   - "늑대가 양보다 많아지는 순간을 어떻게 감지하나요?"
   - "방문 가능한 노드가 없는 경우는 어떻게 처리하나요?"

4. **확장성 고려**:
   - "N이 더 클 때는 어떻게 해결할까요?" → DP, 휴리스틱 탐색, A* 알고리즘
   - "실시간 게임에서는 어떻게 적용할까요?" → 제한된 시간 내 최선의 경로 찾기

5. **실제 업무 적용**:
   - 게임 AI의 의사결정 트리
   - 리소스 제약이 있는 최적화 문제
   - 상태 공간 탐색이 필요한 문제들