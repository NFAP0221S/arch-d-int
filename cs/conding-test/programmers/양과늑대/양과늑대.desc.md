# 📘 양과 늑대

## 📝 문제 설명
2진 트리 모양 초원의 각 노드에 늑대와 양이 한 마리씩 놓여 있습니다. 이 초원의 루트 노드에서 출발하여 각 노드를 돌아다니며 양을 모으려 합니다.

각 노드를 방문할 때마다 해당 노드에 있던 양과 늑대가 당신을 따라오게 됩니다. 이때, 늑대는 양을 잡아먹을 기회를 노리고 있으며, **당신이 모은 양의 수보다 늑대의 수가 같거나 더 많아지면 바로 모든 양을 잡아먹어 버립니다.**

당신은 중간에 양이 늑대에게 잡아먹히지 않도록 하면서 최대한 많은 수의 양을 모아서 다시 루트 노드로 돌아오려 합니다.

## 📌 제한사항
- 2 ≤ info의 길이 ≤ 17
- info의 원소는 0 또는 1입니다
- info[i]는 i번 노드에 있는 양(0) 또는 늑대(1)를 나타냅니다
- info[0]의 값은 항상 0입니다 (루트 노드에는 항상 양이 있음)
- edges의 세로(행) 길이 = info의 길이 - 1
- edges의 가로(열) 길이 = 2
- edges의 각 행은 [부모 노드 번호, 자식 노드 번호] 형태
- 동일한 간선에 대한 정보가 중복해서 주어지지 않습니다
- 항상 하나의 이진 트리 형태로 입력이 주어집니다
- 0번 노드는 항상 루트 노드입니다
- **핵심 조건**: 늑대 수 ≥ 양 수가 되면 모든 양이 잡아먹힘
- 정확성 테스트 시간 제한: 10초

## ✅ 입출력 예
| info | edges | result | 설명 |
|------|-------|--------|------|
| [0,0,1,1,1,0,1,0,1,0,1,1] | [[0,1],[1,2],[1,4],[0,8],[8,7],[9,10],[9,11],[4,3],[6,5],[4,6],[8,9]] | 5 | 최적 경로로 양 5마리 수집 가능 |
| [0,1,0,1,1,0,1,0,0,1,0] | [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6],[3,7],[4,8],[6,9],[9,10]] | 5 | 다른 트리 구조에서 양 5마리 수집 가능 |

## 📌 입출력 예 설명
### 예제 #1
1. **시작**: 0번 노드(양) → 양 1마리
2. **1번 이동**: 0→1번 노드(양) → 양 2마리
3. **8번 이동**: 1→8번 노드(늑대) → 양 2마리, 늑대 1마리
4. **7번, 9번 순회**: → 양 4마리, 늑대 1마리
5. **4번, 6번 이동**: → 양 4마리, 늑대 3마리 (여전히 양 > 늑대)
6. **5번 이동**: → **양 5마리**, 늑대 3마리

### 예제 #2
최적 경로: 0→2→5→1→4→8→3→7 순으로 이동하여 양 5마리 수집

## 💡 해결 아이디어
1. **DFS + 백트래킹**: 모든 가능한 경로를 탐색하되, 늑대 수 ≥ 양 수가 되면 즉시 백트래킹
2. **상태 관리**: 현재 위치, 방문 가능한 노드 집합, 양의 수, 늑대 수를 추적
3. **동적 방문 가능 노드**: 현재 노드를 방문하면 그 자식 노드들이 새로 방문 가능해짐
4. **최적화**: 메모이제이션으로 중복 상태 방지

## ✅ 예시 코드 (JavaScript)
```javascript
function solution(info, edges) {
    // 트리 구조 생성
    const tree = {};
    for (const [parent, child] of edges) {
        if (!tree[parent]) tree[parent] = [];
        tree[parent].push(child);
    }

    let maxSheep = 0;

    function dfs(current, visitableNodes, sheep, wolf) {
        // 현재 노드의 동물 추가
        if (info[current] === 0) sheep++;
        else wolf++;

        // 늑대가 양보다 많아지면 종료
        if (wolf >= sheep) return;

        // 최대 양 수 업데이트
        maxSheep = Math.max(maxSheep, sheep);

        // 새로운 방문 가능 노드 집합 생성
        const newVisitableNodes = new Set(visitableNodes);
        newVisitableNodes.delete(current);

        // 현재 노드의 자식들을 방문 가능 노드에 추가
        if (tree[current]) {
            for (const child of tree[current]) {
                newVisitableNodes.add(child);
            }
        }

        // 방문 가능한 모든 노드에 대해 DFS 진행
        for (const next of newVisitableNodes) {
            dfs(next, newVisitableNodes, sheep, wolf);
        }
    }

    // 0번 노드에서 시작
    dfs(0, new Set([0]), 0, 0);

    return maxSheep;
}
```