# 📊 기능개발 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)

- 각 기능은 **진도 100%에 도달해야 배포 가능**
- **앞 기능이 완료되지 않으면 뒤 기능도 대기** (순차 배포)
- 같은 날에 완료된 기능들은 **함께 배포**
- 각 배포마다 몇 개의 기능이 배포되는지 배열로 반환

## 2단계: 제약/엣지 케이스 점검

- 작업 개수: 1~100 (소규모 데이터)
- 진도: 1~99 (100% 미만)
- 속도: 1~100
- **모든 기능이 같은 날 완료되는 경우** → [전체 개수]
- **각 기능이 모두 다른 날 완료되는 경우** → [1, 1, 1, ...]
- **속도가 매우 느린 첫 번째 기능** → 뒤 기능들이 모두 대기

## 3단계: 브루트포스(비추천) 떠올려보기

```javascript
// 매일 진도를 업데이트하고 배포 가능한 기능 확인
function solutionBrute(progresses, speeds) {
  const result = [];
  let day = 0;

  while (progresses.some(p => p < 100)) {
    day++;
    // 매일 진도 업데이트
    for (let i = 0; i < progresses.length; i++) {
      progresses[i] += speeds[i];
    }

    // 배포 가능한 기능 확인
    let count = 0;
    while (progresses[0] >= 100) {
      progresses.shift();
      speeds.shift();
      count++;
    }
    if (count > 0) result.push(count);
  }
  return result;
}
```
**문제점**: 불필요한 일별 시뮬레이션으로 비효율적

## 4단계: 자료구조/알고리즘 선택 및 이유

- **수학적 계산**: 각 기능의 완료일을 미리 계산 `Math.ceil((100 - progress) / speed)`
- **배열**: 완료일 저장 및 순차 처리
- **그룹핑**: 연속된 기능들의 배포 그룹 형성

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유

- **수학적 계산**: O(1)에 완료일 계산 가능, 시뮬레이션 불필요
- **배열**: 순서가 중요한 데이터 처리에 적합
- **그룹핑**: 앞 기능의 완료일을 기준으로 뒤 기능들의 실제 배포일 결정

## 6단계: 조기 가지치기(Pruning)

- **완료일 미리 계산**: 매일 시뮬레이션 대신 한 번에 계산
- **그룹 단위 처리**: 개별 기능이 아닌 배포 그룹 단위로 결과 생성
- **메모리 최적화**: 별도 배열 대신 인덱스와 카운터만 사용 가능

## 7단계: 구현 (권장)

```javascript
function solution(progresses, speeds) {
  const answer = [];

  // 각 기능의 완료일 계산
  const days = progresses.map((progress, i) =>
    Math.ceil((100 - progress) / speeds[i])
  );

  let maxDay = days[0];  // 현재 배포 그룹의 기준일
  let count = 1;         // 현재 그룹의 기능 개수

  for (let i = 1; i < days.length; i++) {
    if (days[i] <= maxDay) {
      // 앞 기능보다 빨리 완료되므로 같이 배포
      count++;
    } else {
      // 새로운 배포 그룹 시작
      answer.push(count);
      count = 1;
      maxDay = days[i];
    }
  }

  answer.push(count);  // 마지막 그룹 추가
  return answer;
}
```

## 8단계: 대안 구현

```javascript
// 큐를 활용한 구현
function solutionQueue(progresses, speeds) {
  const answer = [];
  const queue = progresses.map((progress, i) =>
    Math.ceil((100 - progress) / speeds[i])
  );

  while (queue.length > 0) {
    const deployDay = queue.shift();
    let count = 1;

    // 같은 날 또는 그 전에 완료되는 기능들 찾기
    while (queue.length > 0 && queue[0] <= deployDay) {
      queue.shift();
      count++;
    }

    answer.push(count);
  }

  return answer;
}

// 스택을 활용한 구현 (역순 처리)
function solutionStack(progresses, speeds) {
  const days = progresses.map((p, i) => Math.ceil((100 - p) / speeds[i]));
  const stack = [];
  const result = [];

  for (let i = days.length - 1; i >= 0; i--) {
    let count = 1;

    while (stack.length > 0 && stack[stack.length - 1] <= days[i]) {
      stack.pop();
      count++;
    }

    stack.push(days[i]);
    result.unshift(count);
  }

  return result;
}
```

## 9단계: 테스트 케이스 세트

```javascript
// 기본 케이스
console.log(solution([93, 30, 55], [1, 30, 5]));
// 완료일: [7, 3, 9] → [2, 1]

console.log(solution([95, 90, 99, 99, 80, 99], [1, 1, 1, 1, 1, 1]));
// 완료일: [5, 10, 1, 1, 20, 1] → [1, 3, 2]

// 모든 기능이 같은 날 완료
console.log(solution([95, 95, 95], [5, 5, 5]));
// 완료일: [1, 1, 1] → [3]

// 각 기능이 다른 날 완료
console.log(solution([10, 20, 30], [10, 10, 10]));
// 완료일: [9, 8, 7] → [1, 1, 1]

// 극단적인 경우: 첫 번째 기능이 매우 느림
console.log(solution([1, 99], [1, 100]));
// 완료일: [99, 1] → [2]

// 단일 기능
console.log(solution([50], [2]));
// 완료일: [25] → [1]
```

## 10단계: 복잡도/확장 & 면접 포인트

### 시간 복잡도
- **완료일 계산**: O(N)
- **그룹핑 처리**: O(N)
- **전체**: O(N)

### 공간 복잡도
- **days 배열**: O(N)
- **결과 배열**: O(배포 횟수) ≤ O(N)
- **전체**: O(N)

### 면접 포인트
1. **수학적 최적화**: 시뮬레이션 vs 직접 계산의 차이점
2. **그룹핑 로직**: 앞 기능의 완료일이 뒤 기능들의 배포 시점을 결정하는 핵심 아이디어
3. **경계 조건**: 마지막 그룹 처리, 빈 입력 등
4. **자료구조 선택**:
   - 배열: 순차 접근에 최적
   - 큐: FIFO 특성 활용
   - 스택: 역순 처리 시 유용
5. **확장성**:
   - 실시간 기능 추가 시 동적 처리 방법
   - 대용량 데이터 처리를 위한 스트리밍
   - 우선순위가 있는 기능 배포 정책
6. **예외 처리**:
   - 진도가 100% 이상인 경우
   - 속도가 0인 경우
   - 음수 입력 처리