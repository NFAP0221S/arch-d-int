# 📊 스킬트리 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)

- **선행 스킬 순서**를 지키는 스킬트리만 유효함
- 선행 스킬에 **포함되지 않은 스킬**은 순서에 상관없이 배울 수 있음
- 각 스킬트리에서 선행 스킬만 추출했을 때, **순서가 올바른지** 판단
- 선행 스킬을 **모두 배울 필요는 없음** (일부만 배워도 됨)

## 2단계: 제약/엣지 케이스 점검

- skill 길이: 1~26 (소규모)
- skill_trees 배열 길이: 1~20 (소규모)
- 각 스킬트리 길이: 2~26
- **빈 선행 스킬**: skill이 ""인 경우 (문제에서 길이 1 이상)
- **선행 스킬이 전혀 없는 스킬트리**: 모두 유효
- **선행 스킬만 있는 스킬트리**: 순서만 맞으면 유효
- **중간 스킬이 빠진 경우**: C→D (B 스킵) 불가능

## 3단계: 브루트포스(비추천) 떠올려보기

```javascript
// 각 스킬트리를 순차적으로 검사
function solutionBrute(skill, skill_trees) {
  let count = 0;

  for (const skillTree of skill_trees) {
    let isValid = true;
    let skillIndex = 0; // 현재 배워야 할 선행 스킬 인덱스

    for (const currentSkill of skillTree) {
      if (skill.includes(currentSkill)) {
        // 선행 스킬에 포함된 경우
        if (skill[skillIndex] === currentSkill) {
          skillIndex++; // 다음 스킬로 진행
        } else {
          // 순서가 틀림
          isValid = false;
          break;
        }
      }
      // 선행 스킬에 없는 경우는 무시
    }

    if (isValid) count++;
  }

  return count;
}
```
**문제점**: 로직이 복잡하고 가독성이 떨어짐

## 4단계: 자료구조/알고리즘 선택 및 이유

- **문자열 필터링**: 선행 스킬에 해당하는 문자만 추출
- **접두사 검사**: 추출된 문자열이 원본 선행 스킬의 접두사인지 확인
- **문자열 메소드**: `includes()`, `filter()`, `startsWith()` 활용

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유

- **필터링 접근법**:
  - 문제를 단순화: 관련 없는 스킬 제거
  - 핵심만 남김: 선행 스킬 순서만 검증
- **접두사 검사**:
  - 부분 학습 허용: 전체를 배우지 않아도 됨
  - 순서 검증: 올바른 순서로 배웠는지 확인
- **내장 메소드**: 코드 간결성과 가독성 향상

## 6단계: 조기 가지치기(Pruning)

- **빈 문자열 검사**: 선행 스킬이 없으면 항상 유효
- **길이 체크**: 추출된 스킬 길이가 원본보다 길면 불가능
- **첫 문자 체크**: 첫 번째 스킬이 맞지 않으면 즉시 실패

## 7단계: 구현 (권장)

```javascript
function solution(skill, skill_trees) {
  let count = 0;

  for (const skillTree of skill_trees) {
    // 선행 스킬에 해당하는 문자들만 추출
    const filteredSkills = skillTree
      .split('')
      .filter(s => skill.includes(s))
      .join('');

    // 추출된 스킬이 선행 스킬 순서의 접두사인지 확인
    if (skill.startsWith(filteredSkills)) {
      count++;
    }
  }

  return count;
}

// 더 함수형 스타일
function solutionFunctional(skill, skill_trees) {
  return skill_trees.filter(skillTree => {
    const relevantSkills = skillTree
      .split('')
      .filter(s => skill.includes(s))
      .join('');

    return skill.startsWith(relevantSkills);
  }).length;
}
```

## 8단계: 대안 구현

```javascript
// 인덱스 추적 방식
function solutionIndex(skill, skill_trees) {
  return skill_trees.filter(skillTree => {
    let skillIndex = 0;

    for (const currentSkill of skillTree) {
      if (skill.includes(currentSkill)) {
        if (skill[skillIndex] === currentSkill) {
          skillIndex++;
        } else {
          return false; // 순서 위반
        }
      }
    }

    return true; // 유효한 스킬트리
  }).length;
}

// 정규표현식 활용
function solutionRegex(skill, skill_trees) {
  const skillSet = new Set(skill);

  return skill_trees.filter(skillTree => {
    const relevantSkills = skillTree
      .split('')
      .filter(s => skillSet.has(s))
      .join('');

    // 정규표현식으로 접두사 확인
    const pattern = new RegExp(`^${skill.slice(0, relevantSkills.length)}$`);
    return pattern.test(relevantSkills);
  }).length;
}

// Map을 활용한 순서 검증
function solutionMap(skill, skill_trees) {
  const skillOrder = new Map();
  skill.split('').forEach((s, i) => skillOrder.set(s, i));

  return skill_trees.filter(skillTree => {
    let expectedIndex = 0;

    for (const currentSkill of skillTree) {
      if (skillOrder.has(currentSkill)) {
        if (skillOrder.get(currentSkill) !== expectedIndex) {
          return false;
        }
        expectedIndex++;
      }
    }

    return true;
  }).length;
}

// 스택 기반 검증
function solutionStack(skill, skill_trees) {
  return skill_trees.filter(skillTree => {
    const stack = skill.split('').reverse(); // 역순으로 스택에 저장

    for (const currentSkill of skillTree) {
      if (skill.includes(currentSkill)) {
        if (stack.length === 0 || stack[stack.length - 1] !== currentSkill) {
          return false;
        }
        stack.pop();
      }
    }

    return true;
  }).length;
}
```

## 9단계: 테스트 케이스 세트

```javascript
// 기본 케이스
console.log(solution("CBD", ["BACDE", "CBADF", "AECB", "BDA"])); // 2

// 모든 스킬트리가 유효한 경우
console.log(solution("ABC", ["ABC", "AB", "A", "BC", "C"])); // 3
// ABC: 완전한 순서 ✅
// AB: 부분 순서 ✅
// A: 부분 순서 ✅
// BC: B 먼저 없이 C 불가 ❌
// C: A,B 없이 C 불가 ❌

// 모든 스킬트리가 무효한 경우
console.log(solution("ABC", ["CBA", "BCA", "BAC"])); // 0

// 선행 스킬이 없는 스킬트리
console.log(solution("ABC", ["XYZ", "DEF"])); // 2

// 선행 스킬만 있는 스킬트리
console.log(solution("ABC", ["ABC", "ACB", "BAC"])); // 1

// 단일 선행 스킬
console.log(solution("A", ["A", "AB", "BA", "XAY"])); // 4

// 복잡한 혼합 케이스
console.log(solution("ABCDE", [
  "ABCDE",    // ✅ 완전 순서
  "ABCDF",    // ✅ 부분 순서 (E 스킵)
  "ABECD",    // ❌ B 다음 E (C 스킵)
  "XABCY",    // ✅ 부분 순서 (X, Y 무관)
  "BACDE"     // ❌ B가 A보다 먼저
])); // 3

// 빈 문자열과 극단 케이스
console.log(solution("A", [""])); // 문제 조건상 길이 2 이상
console.log(solution("ABCDEFGHIJKLMNOPQRSTUVWXYZ", ["ABCDEFGHIJKLMNOPQRSTUVWXYZ"])); // 1
```

## 10단계: 복잡도/확장 & 면접 포인트

### 시간 복잡도
- **필터링 방식**: O(N × M) - N개 스킬트리, 평균 길이 M
- **각 스킬트리 처리**: O(M) - 필터링 + 접두사 검사
- **전체**: O(N × M)

### 공간 복잡도
- **필터링된 문자열**: O(선행 스킬 길이) ≤ O(26)
- **전체**: O(1) - 상수 공간

### 면접 포인트
1. **문제 단순화 접근법**:
   - 복잡한 조건을 간단한 패턴으로 변환
   - 필터링 → 접두사 검사로 문제 축소
2. **접두사 개념의 활용**:
   - 부분 학습을 허용하는 검증 방법
   - `startsWith()` 메소드의 적절한 활용
3. **다양한 구현 방식**:
   - 선언형 vs 명령형
   - 함수형 프로그래밍 패러다임
   - 자료구조별 접근법 (Set, Map, Stack)
4. **확장 가능성**:
   - **분기 스킬 트리**: 여러 경로가 가능한 경우
   - **레벨 제한**: 특정 레벨에서만 배울 수 있는 스킬
   - **동적 스킬 트리**: 런타임에 선행 조건이 변경되는 경우
   - **가중치 스킬**: 스킬마다 배우는 시간이 다른 경우
5. **최적화 고려사항**:
   - Set을 활용한 빠른 포함 확인: O(1)
   - 조기 종료: 첫 번째 위반 시점에서 바로 실패 처리
   - 메모이제이션: 동일한 패턴 재활용
6. **실제 응용 분야**:
   - 게임 스킬 시스템 설계
   - 교육과정 이수 체계 검증
   - 소프트웨어 모듈 의존성 관리
   - 제조 공정 순서 검증