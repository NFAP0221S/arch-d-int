# 📊 주식가격 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)

- 각 시점에서 **해당 가격이 얼마 동안 떨어지지 않았는지** 계산
- **떨어지지 않음**: 현재 가격보다 낮아지지 않음 (같거나 높음)
- **시간 단위**: 초 단위로 측정
- 마지막 시점은 항상 0초 (더 이상 확인할 미래가 없음)

## 2단계: 제약/엣지 케이스 점검

- 가격 범위: 1~10,000 (양의 정수)
- 배열 길이: 2~100,000 (중간 규모 데이터)
- **단조 증가 배열**: 모든 가격이 끝까지 떨어지지 않음
- **단조 감소 배열**: 각 시점에서 1초씩만 유지
- **동일한 가격**: 떨어지지 않은 것으로 간주
- **단일/이중 원소**: 기본 케이스

## 3단계: 브루트포스(비추천) 떠올려보기

```javascript
// 이중 반복문으로 각 시점부터 순차 탐색
function solutionBrute(prices) {
  const result = [];

  for (let i = 0; i < prices.length; i++) {
    let count = 0;
    for (let j = i + 1; j < prices.length; j++) {
      count++;
      if (prices[j] < prices[i]) break; // 가격이 떨어짐
    }
    result.push(count);
  }

  return result;
}
```
**문제점**: O(N²) 시간복잡도, 대용량 데이터에서 비효율적

## 4단계: 자료구조/알고리즘 선택 및 이유

- **모노토닉 스택**: 가격이 감소하는 시점을 효율적으로 찾기
- **인덱스 저장**: 가격과 함께 위치 정보 관리
- **역순 처리**: 뒤에서부터 처리하여 스택 활용 최적화

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유

- **모노토닉 스택**:
  - 각 원소를 최대 2번만 처리 (push 1번, pop 1번)
  - O(N) 시간복잡도 달성
  - 가격 하락 지점을 효율적으로 감지
- **인덱스 기반**: 시간 간격 계산이 간단함

## 6단계: 조기 가지치기(Pruning)

- **마지막 원소**: 항상 0이므로 별도 처리
- **스택 비우기**: 남은 원소들은 끝까지 떨어지지 않았음을 의미
- **단조성 활용**: 스택에서 현재보다 큰 가격들을 제거

## 7단계: 구현 (권장)

### 💻 기본 구현 (이중 반복문) - O(N²)
```javascript
function solution(prices) {
  const answer = Array(prices.length).fill(0);

  for (let i = 0; i < prices.length; i++) {
    for (let j = i + 1; j < prices.length; j++) {
      answer[i]++;
      if (prices[j] < prices[i]) break;
    }
  }

  return answer;
}
```

### 🚀 최적화 구현 (모노토닉 스택) - O(N)
```javascript
function solutionOptimized(prices) {
  const answer = Array(prices.length).fill(0);
  const stack = []; // 인덱스를 저장

  for (let i = 0; i < prices.length; i++) {
    // 현재 가격보다 높은 이전 가격들의 지속 시간 계산
    while (stack.length > 0 && prices[stack[stack.length - 1]] > prices[i]) {
      const index = stack.pop();
      answer[index] = i - index;
    }
    stack.push(i);
  }

  // 스택에 남은 인덱스들은 끝까지 가격이 떨어지지 않았음
  while (stack.length > 0) {
    const index = stack.pop();
    answer[index] = prices.length - 1 - index;
  }

  return answer;
}
```

## 8단계: 대안 구현

```javascript
// 역순 처리를 통한 스택 최적화
function solutionReverse(prices) {
  const n = prices.length;
  const answer = Array(n).fill(0);
  const stack = []; // [가격, 인덱스] 저장

  for (let i = n - 1; i >= 0; i--) {
    let count = 0;

    // 현재 가격보다 낮은 미래 가격들 제거
    while (stack.length > 0 && stack[stack.length - 1][0] >= prices[i]) {
      const [price, index] = stack.pop();
      count += 1 + answer[index]; // 누적 계산
    }

    if (stack.length > 0) {
      // 떨어지는 지점이 있음
      answer[i] = count + 1;
    } else {
      // 끝까지 떨어지지 않음
      answer[i] = n - 1 - i;
    }

    stack.push([prices[i], i]);
  }

  return answer;
}

// 세그먼트 트리를 활용한 고급 구현 (오버엔지니어링)
function solutionSegmentTree(prices) {
  // 복잡도가 높아 실용적이지 않음
  // 특수한 쿼리 처리가 필요한 경우에만 사용
}

// 병렬 처리를 고려한 분할 정복
function solutionDivideConquer(prices, start = 0, end = prices.length - 1) {
  if (start === end) return [0];

  const mid = Math.floor((start + end) / 2);
  const left = solutionDivideConquer(prices, start, mid);
  const right = solutionDivideConquer(prices, mid + 1, end);

  // 경계 처리 로직 (복잡함)
  return [...left, ...right];
}
```

## 9단계: 테스트 케이스 세트

```javascript
// 기본 케이스
console.log(solution([1, 2, 3, 2, 3]));
// 예상: [4, 3, 1, 1, 0]

// 단조 증가
console.log(solution([1, 2, 3, 4, 5]));
// 예상: [4, 3, 2, 1, 0]

// 단조 감소
console.log(solution([5, 4, 3, 2, 1]));
// 예상: [1, 1, 1, 1, 0]

// 모든 가격이 동일
console.log(solution([3, 3, 3, 3]));
// 예상: [3, 2, 1, 0]

// 최소 케이스
console.log(solution([1, 2]));
// 예상: [1, 0]

console.log(solution([2, 1]));
// 예상: [1, 0]

// 복잡한 패턴
console.log(solution([1, 2, 1, 2, 1]));
// 예상: [4, 1, 2, 1, 0]

// 극단적인 경우
console.log(solution([10000, 1, 10000]));
// 예상: [1, 1, 0]

// 대용량 테스트 (성능 확인)
const largePrices = Array.from({length: 10000}, (_, i) => Math.floor(Math.random() * 10000) + 1);
console.time("Large test");
solution(largePrices);
console.timeEnd("Large test");
```

## 10단계: 복잡도/확장 & 면접 포인트

### 시간 복잡도
- **이중 반복문**: O(N²) - 최악의 경우 모든 조합 확인
- **모노토닉 스택**: O(N) - 각 원소를 최대 2번 처리
- **공간 복잡도**: O(N) - 결과 배열과 스택

### 면접 포인트
1. **알고리즘 진화**:
   - 브루트포스 → 스택 최적화 과정 설명
   - 시간복잡도 개선: O(N²) → O(N)
2. **모노토닉 스택 원리**:
   - 단조성을 유지하는 이유
   - 스택에 저장하는 정보 (인덱스 vs 값)
   - pop 조건과 타이밍
3. **경계 조건 처리**:
   - 마지막 원소는 항상 0
   - 스택에 남은 원소들의 처리
   - 빈 배열, 단일 원소 케이스
4. **확장성 고려사항**:
   - **실시간 스트리밍**: 데이터가 실시간으로 들어오는 경우
   - **범위 쿼리**: 특정 구간의 지속시간 합계
   - **다중 조건**: 가격뿐만 아니라 거래량도 고려
   - **병렬 처리**: 대용량 데이터 분할 처리
5. **최적화 기법**:
   - 메모리 효율성: 인덱스만 저장
   - 캐시 친화적: 순차 접근 패턴
   - 조기 종료: 특정 조건에서 빠른 반환
6. **실제 응용 분야**:
   - 주식 기술적 분석
   - 시계열 데이터 패턴 분석
   - 게임에서의 연속 기록 계산
   - 서버 모니터링에서의 안정성 지표