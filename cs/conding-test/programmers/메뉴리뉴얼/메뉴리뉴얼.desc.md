# 📘 메뉴 리뉴얼

## 📝 문제 설명

레스토랑을 운영하던 **스카피**는 코로나19로 인한 불경기를 극복하고자 **메뉴를 코스요리 형태로 재구성**하기로 했습니다.

기존 단품 메뉴들을 조합하여 가장 인기 있었던 조합을 **코스요리 후보**로 선택합니다.

- 각 손님은 2개 이상의 단품 메뉴를 주문합니다.
- 단품 메뉴는 알파벳 대문자 (A-Z)로 표현됩니다.
- **최소 2명 이상의 손님**이 주문한 조합만 후보가 됩니다.
- 메뉴 구성은 **코스 종류(course)**로 주어지며, 이는 메뉴 조합의 길이를 의미합니다.

---

## ✅ 예시

| 손님 번호 | 주문한 단품메뉴 조합 |
| --------- | -------------------- |
| 1번       | A, B, C, F, G        |
| 2번       | A, C                 |
| 3번       | C, D, E              |
| 4번       | A, C, D, E           |
| 5번       | B, C, F, G           |
| 6번       | A, C, D, E, H        |

→ "스카피"가 구성하게 될 코스요리 메뉴 후보는 다음과 같습니다:

| 코스 종류     | 메뉴 구성  | 설명                              |
| ------------- | ---------- | --------------------------------- |
| 요리 2개 코스 | A, C       | 1, 2, 4, 6번 손님이 주문 → 총 4회 |
| 요리 3개 코스 | C, D, E    | 3, 4, 6번 손님이 주문 → 총 3회    |
| 요리 4개 코스 | B, C, F, G | 1, 5번 손님이 주문 → 총 2회       |
| 요리 4개 코스 | A, C, D, E | 4, 6번 손님이 주문 → 총 2회       |

---

## 📌 입력 설명

### 매개변수

- `orders`: 문자열 배열 – 각 손님이 주문한 단품 메뉴 조합
- `course`: 정수 배열 – 코스요리로 만들 단품 메뉴 개수들

---

## 📌 제한사항

- `orders.length`: 2 이상 20 이하
- `orders[i]`: 길이 2 이상 10 이하 문자열, 알파벳 대문자만, 중복 없음
- `course.length`: 1 이상 10 이하의 정수 배열 (오름차순, 중복 없음)
- 정답은 **사전 순**으로 정렬되어야 하며, 메뉴 조합의 알파벳도 정렬된 상태여야 함
- 반환 배열은 **길이 1 이상**이어야 함

---

## ✅ 입출력 예

| orders                                              | course    | result                              |
| --------------------------------------------------- | --------- | ----------------------------------- |
| `["ABCFG", "AC", "CDE", "ACDE", "BCFG", "ACDEH"]`   | `[2,3,4]` | `["AC", "ACDE", "BCFG", "CDE"]`     |
| `["ABCDE", "AB", "CD", "ADE", "XYZ", "XYZ", "ACD"]` | `[2,3,5]` | `["ACD", "AD", "ADE", "CD", "XYZ"]` |
| `["XYZ", "XWY", "WXA"]`                             | `[2,3,4]` | `["WX", "XY"]`                      |

---

## 📌 입출력 예 설명

### 예제 #1

문제 본문과 동일

### 예제 #2

- AD: 3번, CD: 3번, ACD: 2번, ADE: 2번, XYZ: 2번 등장
- 요리 5개 코스는 주문자가 1명뿐이므로 제외

### 예제 #3

- WX: 2번, XY: 2번 등장
- 요리 3개/4개 코스는 조건 불충족 → 제외

---

## 💡 해결 아이디어

1. 각 주문을 **오름차순 정렬**하여 조합 생성을 표준화
2. `itertools.combinations` 또는 유사 기능으로 코스 길이에 따른 **모든 조합 생성**
3. 조합의 **빈도수 계산** (딕셔너리 또는 Map 사용)
4. 각 코스 길이별로 **최대 빈도수를 갖는 조합**만 필터링 (단, 2 이상 등장)
5. 결과는 **사전 순 정렬** 후 반환

---

## ✅ 예시 코드 (JavaScript)

```js
function solution(orders, course) {
  const getCombinations = (arr, n) => {
    if (n === 1) return arr.map((v) => [v]);
    const result = [];
    arr.forEach((v, i) => {
      const rest = arr.slice(i + 1);
      const combos = getCombinations(rest, n - 1);
      result.push(...combos.map((combo) => [v, ...combo]));
    });
    return result;
  };

  const map = new Map();

  for (let order of orders) {
    const sorted = [...order].sort();
    for (let c of course) {
      const combos = getCombinations(sorted, c);
      combos.forEach((combo) => {
        const key = combo.join("");
        map.set(key, (map.get(key) || 0) + 1);
      });
    }
  }

  const result = [];

  for (let c of course) {
    let max = 0;
    const temp = [];

    for (let [k, v] of map.entries()) {
      if (k.length === c && v >= 2) {
        if (v > max) {
          max = v;
          temp.length = 0;
          temp.push(k);
        } else if (v === max) {
          temp.push(k);
        }
      }
    }

    result.push(...temp);
  }

  return result.sort();
}
```
