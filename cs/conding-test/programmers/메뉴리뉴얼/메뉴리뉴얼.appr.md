# 📊 메뉴리뉴얼 - 분석

## 1단계: 문제 재정의 (핵심 조건 정리)

- 여러 손님의 주문 조합에서 **가장 많이 주문된 메뉴 조합**을 찾는 문제
- 각 코스 길이별로 **최대 빈도수를 갖는 조합**을 선택
- **최소 2명 이상**이 주문한 조합만 후보가 됨
- 결과는 **사전 순 정렬**되어야 함

## 2단계: 제약/엣지 케이스 점검

- `orders.length`: 2~20 (적은 데이터, 완전탐색 가능)
- `orders[i]`: 길이 2~10 (조합 생성 시 고려)
- `course.length`: 1~10 (여러 코스 길이 처리)
- 모든 조합이 1명만 주문하는 경우 → 빈 결과 반환
- 동일한 최대 빈도수를 갖는 조합이 여러 개인 경우 → 모두 포함

## 3단계: 브루트포스(비추천) 떠올려보기

```javascript
// 모든 가능한 조합을 생성하고 빈도 계산
for (let order of orders) {
  for (let size of course) {
    // 모든 size 길이의 조합 생성
    // 빈도수 계산
  }
}
```
**문제점**: 조합 생성이 비효율적이고 중복 계산 발생

## 4단계: 자료구조/알고리즘 선택 및 이유

- **조합(Combination) 알고리즘**: 각 주문에서 지정된 길이의 모든 조합 생성
- **해시맵(Map)**: 조합별 빈도수 저장 및 빠른 조회
- **정렬**: 각 주문 내 메뉴를 정렬하여 조합의 일관성 보장

## 5단계: 4단계에서 자료구조/알고리즘 선택한 이유

- **조합 알고리즘**: 순서와 상관없이 메뉴의 집합을 다루므로 조합이 적합
- **해시맵**: O(1) 시간에 빈도수 조회/업데이트 가능
- **정렬**: "AC"와 "CA"가 같은 조합임을 보장하기 위해 필요

## 6단계: 조기 가지치기(Pruning)

- 주문 길이가 코스 길이보다 작은 경우 조합 생성 스킵
- 빈도수가 2 미만인 조합은 결과에서 제외
- 각 코스 길이별로 최대 빈도수만 추려서 불필요한 조합 제거

## 7단계: 구현 (권장)

```javascript
function solution(orders, course) {
  // 조합 생성 함수
  const getCombinations = (arr, n) => {
    if (n === 1) return arr.map(v => [v]);
    const result = [];
    arr.forEach((v, i) => {
      const rest = arr.slice(i + 1);
      const combos = getCombinations(rest, n - 1);
      result.push(...combos.map(combo => [v, ...combo]));
    });
    return result;
  };

  const frequencyMap = new Map();

  // 모든 주문에서 조합 생성 및 빈도 계산
  for (let order of orders) {
    const sortedOrder = [...order].sort(); // 일관성 보장

    for (let courseSize of course) {
      if (sortedOrder.length >= courseSize) {
        const combinations = getCombinations(sortedOrder, courseSize);

        combinations.forEach(combo => {
          const key = combo.join('');
          frequencyMap.set(key, (frequencyMap.get(key) || 0) + 1);
        });
      }
    }
  }

  const result = [];

  // 각 코스 길이별로 최대 빈도수 조합 찾기
  for (let courseSize of course) {
    let maxFreq = 0;
    const candidates = [];

    for (let [combination, freq] of frequencyMap.entries()) {
      if (combination.length === courseSize && freq >= 2) {
        if (freq > maxFreq) {
          maxFreq = freq;
          candidates.length = 0;
          candidates.push(combination);
        } else if (freq === maxFreq) {
          candidates.push(combination);
        }
      }
    }

    result.push(...candidates);
  }

  return result.sort(); // 사전순 정렬
}
```

## 8단계: 대안 구현

```javascript
// 재귀 없는 조합 생성 (비트마스크 활용)
function getCombinationsIterative(arr, r) {
  const result = [];
  const n = arr.length;

  for (let mask = 0; mask < (1 << n); mask++) {
    if (countBits(mask) === r) {
      const combo = [];
      for (let i = 0; i < n; i++) {
        if (mask & (1 << i)) {
          combo.push(arr[i]);
        }
      }
      result.push(combo);
    }
  }
  return result;
}

function countBits(n) {
  let count = 0;
  while (n) {
    count += n & 1;
    n >>= 1;
  }
  return count;
}
```

## 9단계: 테스트 케이스 세트

```javascript
// 기본 케이스
console.log(solution(["ABCFG", "AC", "CDE", "ACDE", "BCFG", "ACDEH"], [2,3,4]));
// 예상: ["AC", "ACDE", "BCFG", "CDE"]

// 모든 조합이 1번만 나오는 경우
console.log(solution(["ABC", "DEF", "GHI"], [2]));
// 예상: []

// 동일한 빈도수가 여러 개인 경우
console.log(solution(["AB", "AC", "BC"], [2]));
// 예상: ["AB", "AC", "BC"]

// 단일 코스 길이
console.log(solution(["ABCD", "ABCD", "ABCD"], [4]));
// 예상: ["ABCD"]
```

## 10단계: 복잡도/확장 & 면접 포인트

### 시간 복잡도
- **조합 생성**: O(N × C(M, K)) - N개 주문, 평균 길이 M, 코스 길이 K
- **전체**: O(N × M × C(M, K) × |course|)
- 실제로는 M ≤ 10, |course| ≤ 10이므로 충분히 효율적

### 공간 복잡도
- **해시맵**: O(총 생성된 조합 수) = O(N × C(M, K) × |course|)

### 면접 포인트
1. **조합 vs 순열**: 메뉴 순서는 중요하지 않으므로 조합 선택
2. **정렬의 필요성**: 동일한 조합을 일관되게 표현하기 위함
3. **최적화 기법**:
   - 주문 길이 < 코스 길이인 경우 스킵
   - 빈도수 2 미만 조합 제거
4. **확장성**:
   - 대용량 데이터 처리 시 분산 처리 고려
   - 메모리 효율성을 위한 스트리밍 처리
5. **예외 처리**: 빈 입력, 유효하지 않은 코스 길이 등